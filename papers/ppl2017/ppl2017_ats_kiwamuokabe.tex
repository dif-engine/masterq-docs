\documentclass[japanese]{jssst_ppl} %% 日本語 (default)
% \documentclass[english]{jssst_ppl} %% English
% \documentclass[japanese,draft]{jssst_ppl} %% You can use the draft option
\usepackage{url}
\usepackage{listings}

\title{C言語ヘッダからのATS言語関数シグニチャの自動生成と段階的な線形型の導入}
\author{岡部 究$^1$}
\inst{%
$^1$ 理化学研究所 計算科学研究機構\\
\texttt{kiwamu@debian.or.jp}
}
\begin{document}
\lstset{ %
  basicstyle=\footnotesize,        % the size of the fonts that are used for the code
  breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace
  breaklines=true,                 % sets automatic line breaking
  captionpos=b,                    % sets the caption-position to bottom
  deletekeywords={...},            % if you want to delete keywords from the given language
  escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
  extendedchars=true,              % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
  frame=single,	                   % adds a frame around the code
  keepspaces=true,                 % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
  morekeywords={*,...},           % if you want to add more keywords to the set
  numbers=left,                    % where to put the line-numbers; possible values are (none, left, right)
  numbersep=5pt,                   % how far the line-numbers are from the code
  showspaces=false,                % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
  showstringspaces=false,          % underline spaces within strings only
  showtabs=false,                  % show tabs within strings adding particular underscores
  tabsize=2,	                   % sets default tabsize to 2 spaces
  title=\lstname                   % show the filename of files included with \lstinputlisting; also try caption instead of title
}
\maketitle
\begin{abstract}
C言語を用いた低レベルなプログラミングにおいてメモリ破壊やリソースリークはやっかいな問題です。C言語の代替としてATS言語を採用し、線形型を用いてメモリアクセス権限やリソース生存範囲を表明することで、これらの違反をコンパイル時検査できることが知られています。しかし既存のC言語コード資産の上でATS言語実装を動かすには、当該C言語関数をATS言語にインポートする必要がありました。本論文では、この明らかに人為的なミスを誘発するプロセスをコード生成によって自動化するc2atsというツールを提案します。さらに、自動生成された関数シグニチャを使って危険なATSコードを作成した後、当該関数シグニチャに手動で線形型を導入することで、段階的にATSコードの安全性を向上できることを示します。
\end{abstract}

\section{はじめに}
近年プログラミング言語の進化はめざましく、ガベージコレクション/型推論/関数型プログラミングのような機能を備えた言語を用いて高い生産性でアプリケーションを作ることが可能になりました。しかし組み込み開発におけるハードウェアに近い領域でのプログラミングはC言語を用いた開発を余儀なくされています。C言語を用いた場合、その設計はバッファオーバフローのようなメモリ破壊やリソースリークのような不具合を容易にひきおこします。またC言語の機能は一般的な関数型言語よりも貧弱であり、代数的データ型のような今日一般的な機能でさえ使うことができません。

この大きな課題に対して様々な手法が提案されています。1つ目は静的コード解析\cite{Bessey:2010:FBL:1646353.1646374}と呼ばれる手法で、C言語コードをそのまま静的解析して不正なメモリ使用やリソースリークを防止します。しかしこのような解析器は多くのフォールスポジティブ(誤検知)やフォールスネガティブ(見逃し)を誘発してしまいます。またこの手法では設計基盤にC言語を使っているため型推論や関数型プログラミングの機能を使うことは困難です。

2つ目はC言語のコード中に表明を手動で注入して、その表明を静的に検証する方法\cite{Frama-C}\cite{VeriFast}です。1つ目の手法と異なり、この手法を用いることでメモリの不正使用やリソースリークを正確に検出できます。しかしこの手法でも設計基盤にC言語を使っているため型推論や関数型プログラミングの機能を使うことはやはり困難です。

3つ目は低レベルプログラミング向けにC言語ではない新しい言語を導入する手法\cite{danish2015terrier}\cite{light2015reenix}です。その新しい言語の機能を使うことで、メモリの不正使用やリソースリークを正確に検出でき、さらに型推論や関数型プログラミングの機能を使うことも可能になります。しかし既存のC言語資産と協調動作をする場合にはC言語関数を当該言語にインポートする必要があります。このインポートは主に手動で行なわれるため人為的なミスを誘発する可能性があります。

本論文では上記3つ目の手法の具体例としてATS言語を紹介した後、この手法が持つ問題点を解決するために当該インポートをコード生成によって自動化するc2atsというツールを提案します。このc2atsを用いて生成された関数シグニチャを使って危険なアプリケーションをATS言語で書いた後、当該関数シグニチャに手動で段階的に線形型を導入することで当該アプリケーションに発生しうるメモリの不正使用やリソースリークを除去することができることを示します。

\section{ATS言語概要}

ATS言語\cite{xi2003applied}\cite{ats}は静的型付けのプログラミング言語で、依存型と線形型をそなえています。

xxx dats/satsについて説明
xxx patsccコマンドの使い方
xxx unsafe.satsについて \verb|ptr_vtake|
xxx 静的な変数について説明

\section{線形型による安全なメモリ使用とリソースの追跡}

xxx 証明引数と実引数について説明
xxx 駐観について説明
xxx addr sortについて説明

\section{ATS言語からのC言語関数呼び出し}
\section{c2ats概要}

前章でC言語関数をATS言語から呼び出せることがわかりましたが、そのためのインポートは手動で行なわれました。この手作業でのインポートにおいて人為的なミスがあった場合、どんなにATSコンパイラが正しく型検査したとしても、インポート元のC言語関数とインポートされたATS関数シグニチャの型が合わないために不具合が混入してしまいます。

例えば、xxx

そこで筆者はc2ats\cite{c2ats}というツールを開発中です。本章ではc2atsの詳細を解説する前にその使い方を通して概要を説明します。まず下記のようなexample.hファイルがあるとします。

\lstinputlisting{example/hello/example.h}

このときコンソールから以下のようにc2atsを実行することによってexample.satsファイルを自動生成できます。

\begin{lstlisting}
$ cd example/hello
$ c2ats gen example.h > example.sats
\end{lstlisting}

この生成されたexample.satsファイルにはexample.hがインクルードしていたstdio.hで宣言されている全ての関数がインポートされています。例えば \verb|printf| 関数は以下のように自動的にexample.satsファイルにインポートされます。

\begin{lstlisting}
$ vi example.sats
--snip--
viewdef ptr_v_1 (a:t@ype, l:addr) = a @ l
--snip--
fun fun_c2ats_printf: {l1:addr} (!ptr_v_1(char, l1) | ptr l1) -> int = "mac#printf"
--snip--
\end{lstlisting}

まず、このインポートされた \verb|printf| 関数には、既存のATSライブラリと干渉しないように、\verb|fun_c2ats_printf| という別名が付けられます。その第1引数は証明引数で、アドレス \verb|l1| に型 \verb|char| のデータがあること表明しています。通常の駐観の形式ではなく、\verb|ptr_v_1| という別名を使っているのは多段ポインタに対応するためですが、詳しくは次章で解説します。第2引数は実引数でポインタです。これら2つの引数は同時に \verb|l1| という静的な変数に依存していて、その種は \verb|addr| です。ATS言語ではC言語の可変長引数を扱う良い方法がないために、この \verb|fun_c2ats_printf| 関数は単に文字列を印字することしかできません。

この \verb|fun_c2ats_printf| 関数を用いたATSコードを以下のように作ることができます。

\lstinputlisting{example/hello/main.dats}

上記のmain.datsは以下のようにATSコンパイラでコンパイルすることができます。

\begin{lstlisting}
$ cd example/hello
$ patscc -o test_prog main.dats
$ ./test_prog
Hello, world!
\end{lstlisting}

しかしこのmain.datsコードは以下の点で危険なコードです。

\begin{itemize}
\item 危険なAPIの入ったunsafe.satsをインポートしている
\item 何の証明もない単なるポインタから任意の駐観を取り出せる \verb|ptr_vtake| を使っている
\end{itemize}

これらの問題は、c2atsがC言語のポインタを真面目に解釈した結果、自動生成された \verb|fun_c2ats_printf| 関数が \verb|char| への駐観を取るように定義されてしまっているために生じています。そこで、自動生成されたexample.satsを以下のように \verb|fun_c2ats_printf| がATS言語の \verb|string| 型を取るように手動で修正してみます。

\begin{lstlisting}
$ cp example.sats example_welltyped.sats
$ vi example_welltyped.sats
--snip--
fun fun_c2ats_printf: (string) -> int = "mac#printf"
--snip--
\end{lstlisting}

これでmain.datsを次のようにシンプルに書き直すことができます。

\lstinputlisting{example/welltyped_hello/main.dats}

新しいコードには先のような危険な問題はありません。このように、C言語とATS言語を協調させたプログラミングにおいて、c2atsがインポートした関数シグニチャはATSプログラマが真に欲しい型表現ではありません。これはc2atsがまだ開発途上であることにも原因がありますが、より大きな課題はC言語の関数定義がATS言語で使いたいレベルの不変条件を表明していないことに起因しています。このC言語における表明の不足については後の章で具体的に解説します。

現時点においてはc2atsの作るsatsファイルはRuby on Rails\cite{rails}のScaffoldのようなものだと考えることができます。c2atsで自動生成されたsatsファイルは手っ取り早くATSアプリケーションを作るための足場にすぎません。当該satsファイル内の関数シグニチャに問題があれば、手動で強化すべきです。当該satsファイルは、決っして製品コードにそのまま無変更で採用されるべきではありません。そのsatsファイルは多くの危険な関数シグニチャを含んでいるからです。しかしその危険性は元のC言語関数定義と同等のものです。

別の言い方をすると、元々危険であったC言語関数インターフェイスがc2atsによってATS言語に写像されることで、ATSプログラマはその危険性をunsafe.satsなどの含む危険なキャストの使用という形で明確に知覚できるようになります。一旦知覚された危険性はその危険なコードを手動除去する過程で自然に安全になります。結果自動生成されたsatsファイルは段階的に安全性を高めることが可能になります。

\section{c2atsによる自動生成ルール}

xxx \verb|ptr_v_1| について説明

\section{現実的なアプリケーション: 自動生成された危険な関数の使用}
\section{現実的なアプリケーション: 段階的な線形型の導入}
\section{現時点での制限}
\section{関連研究}

xxx c2hsとcorrodeについて簡単に紹介

\section{結論と今後}

\section{謝辞}
C言語の型表現をいかにしてATS言語の型表現に解釈しなおすか、その筆者の疑問に対し根気強いサポートをしてくれたHongwei Xiに感謝します。

% BibTeX %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\bibliographystyle{unsrt}
\bibliography{../bibtex/reference,../bibtex/jreference}

\end{document}
