\documentclass[japanese]{jssst_ppl} %% 日本語 (default)
% \documentclass[english]{jssst_ppl} %% English
% \documentclass[japanese,draft]{jssst_ppl} %% You can use the draft option
\usepackage{url}
\usepackage{listings}

\title{C言語ヘッダからのATS言語関数シグニチャの自動生成と段階的な線形型の導入}
\author{岡部 究$^1$}
\inst{%
$^1$ 理化学研究所 計算科学研究機構\\
\texttt{kiwamu@debian.or.jp}
}
\begin{document}
\lstset{ %
  basicstyle=\footnotesize,        % the size of the fonts that are used for the code
  breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace
  breaklines=true,                 % sets automatic line breaking
  captionpos=b,                    % sets the caption-position to bottom
  deletekeywords={...},            % if you want to delete keywords from the given language
  escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
  extendedchars=true,              % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
  frame=single,	                   % adds a frame around the code
  keepspaces=true,                 % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
  morekeywords={*,...},           % if you want to add more keywords to the set
  numbers=left,                    % where to put the line-numbers; possible values are (none, left, right)
  numbersep=5pt,                   % how far the line-numbers are from the code
  showspaces=false,                % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
  showstringspaces=false,          % underline spaces within strings only
  showtabs=false,                  % show tabs within strings adding particular underscores
  tabsize=2,	                   % sets default tabsize to 2 spaces
}
\maketitle
\begin{abstract}
C言語を用いた低レベルなプログラミングにおいてメモリ破壊やリソースリークはやっかいな問題です。C言語の代替としてATS言語を採用し、線形型を用いてメモリアクセス権限やリソース生存範囲を表明することで、これらの違反をコンパイル時検査できることが知られています。しかし既存のC言語コード資産の上でATS言語実装を動かすには、当該C言語関数をATS言語にインポートする必要がありました。本論文では、この明らかに人為的なミスを誘発するプロセスをコード生成によって自動化するc2atsというツールを提案します。さらに、自動生成された関数シグニチャを使って危険なATSコードを作成した後、当該関数シグニチャに手動で線形型を導入することで、段階的にATSコードの安全性を向上できることを示します。
\end{abstract}

\section{はじめに}
近年プログラミング言語の進化はめざましく、ガベージコレクション/型推論/関数型プログラミングのような機能を備えた言語を用いて高い生産性でアプリケーションを作ることが可能になりました。しかし組み込み開発におけるハードウェアに近い領域でのプログラミングはC言語を用いた開発を余儀なくされています。C言語を用いた場合、その設計はバッファオーバフローのようなメモリ破壊やリソースリークのような不具合を容易にひきおこします。またC言語の機能は一般的な関数型言語よりも貧弱であり、代数的データ型のような今日一般的な機能でさえ使うことができません。

この大きな課題に対して様々な手法が提案されています。1つ目は静的コード解析\cite{Bessey:2010:FBL:1646353.1646374}と呼ばれる手法で、C言語コードをそのまま静的解析して不正なメモリ使用やリソースリークを防止します。しかしこのような解析器は多くのフォールスポジティブ(誤検知)やフォールスネガティブ(見逃し)を誘発してしまいます。またこの手法では設計基盤にC言語を使っているため型推論や関数型プログラミングの機能を使うことは困難です。

2つ目はC言語のコード中に表明を手動で注入して、その表明を静的に検証する方法\cite{Frama-C}\cite{VeriFast}です。1つ目の手法と異なり、この手法を用いることでメモリの不正使用やリソースリークを正確に検出できます。しかしこの手法でも設計基盤にC言語を使っているため型推論や関数型プログラミングの機能を使うことはやはり困難です。

3つ目は低レベルプログラミング向けにC言語ではない新しい言語を導入する手法\cite{danish2015terrier}\cite{light2015reenix}です。その新しい言語の機能を使うことで、メモリの不正使用やリソースリークを正確に検出でき、さらに型推論や関数型プログラミングの機能を使うことも可能になります。しかし既存のC言語資産と協調動作をする場合にはC言語関数を当該言語にインポートする必要があります。このインポートは主に手動で行なわれるため人為的なミスを誘発する可能性があります。

本論文では上記3つ目の手法の具体例としてATS言語を紹介した後、この手法が持つ問題点を解決するために当該インポートをコード生成によって自動化するc2atsというツールを提案します。このc2atsを用いて生成された関数シグニチャを使って危険なアプリケーションをATS言語で書いた後、当該関数シグニチャに手動で段階的に線形型を導入することで当該アプリケーションに発生しうるメモリの不正使用やリソースリークを除去することができることを示します。

\section{ATS言語概要}

ATS言語\cite{xi2003applied}\cite{ats}は静的型付けのプログラミング言語で、依存型と線形型をそなえています。

xxx dats/satsについて
xxx patsccコマンドの使い方
xxx unsafe.satsについて \verb|ptr_vtake|
xxx 静的な変数について
xxx 量化について

\section{線形型による安全なメモリ使用とリソースの追跡}

xxx 証明引数と実引数について
xxx 駐観について
xxx addr sortについて
xxx 証明関数について
xxx 生成と消費について
xxx 観変化について
xxx 文字列型string,strptr,strnptrについて

\section{c2ats概要}

前章でC言語関数をATS言語から呼び出せることがわかりましたが、そのためのインポートは手動で行なわれました。この手作業でのインポートにおいて人為的なミスがあった場合、どんなにATSコンパイラが正しく型検査したとしても、インポート元のC言語関数とインポートされたATS関数シグニチャの型が合わないために不具合が混入してしまいます。

そこで筆者はc2ats\cite{c2ats}というツールを開発中です。本章ではc2atsの詳細を解説する前にその使い方を通して概要を説明します。まず下記のようなexample.hファイルがあるとします。

\lstinputlisting{example/hello/example.h}

このときコンソールから以下のようにc2atsを実行することによってexample.satsファイルを自動生成できます。

\begin{lstlisting}
$ cd example/hello
$ c2ats gen example.h > example.sats
\end{lstlisting}

上記の生成されたexample.satsファイルには先のexample.hからインクルードしていたstdio.hで宣言されている全ての関数がインポートされています。例えばC言語の \verb|printf| 関数は以下のように自動的にexample.satsファイルにインポートされます。

\begin{lstlisting}
$ vi example.sats
--snip--
viewdef ptr_v_1 (a:t@ype, l:addr) = a @ l
--snip--
fun fun_c2ats_printf: {l1:addr} (!ptr_v_1(char, l1) | ptr l1) -> int = "mac#printf"
--snip--
\end{lstlisting}

まず、このインポートされた \verb|printf| 関数には、既存のATSライブラリと干渉しないように、\verb|fun_c2ats_printf| という別名が付けられます。その第1引数は証明引数で、アドレス \verb|l1| に型 \verb|char| のデータがあること表明しています。通常の駐観の形式ではなく、\verb|ptr_v_1| という別名を使っているのは多段ポインタに対応するためですが、詳しくは次章で解説します。第2引数は実引数でポインタです。これら2つの引数は同時に \verb|l1| という静的な変数に依存していて、その種は \verb|addr| です。ATS言語ではC言語の可変長引数を扱う良い方法がないために、この \verb|fun_c2ats_printf| 関数は単に文字列を印字することしかできません。

この \verb|fun_c2ats_printf| 関数を用いたATSコードを以下のように作ることができます。

\lstinputlisting{example/hello/main.dats}

上記のmain.datsは以下のようにATSコンパイラでコンパイルすることができます。

\begin{lstlisting}
$ cd example/hello
$ patscc -o test_prog main.dats
$ ./test_prog
Hello, world!
\end{lstlisting}

しかしこのmain.datsコードは以下の点で危険なコードです。

\begin{itemize}
\item 危険なAPIの入ったunsafe.satsをインポートしている
\item 何の証明もない単なるポインタから任意の駐観を取り出せる \verb|ptr_vtake| を使っている
\end{itemize}

これらの問題は、c2atsがC言語のポインタを真面目に解釈した結果、自動生成された \verb|fun_c2ats_printf| 関数が \verb|char| への駐観を取るように定義されてしまっているために生じています。そこで、自動生成されたexample.satsを以下のように \verb|fun_c2ats_printf| がATS言語の \verb|string| 型を取るように手動で修正してみます。

\begin{lstlisting}
$ cp example.sats example_welltyped.sats
$ vi example_welltyped.sats
--snip--
fun fun_c2ats_printf: (string) -> int = "mac#printf"
--snip--
\end{lstlisting}

これでmain.datsを次のようにシンプルに書き直すことができます。

\lstinputlisting{example/welltyped_hello/main.dats}

上記の新しいコードには先のような危険な問題はありません。このように、C言語とATS言語を協調させたプログラミングにおいて、c2atsが直接インポートした関数シグニチャはATSプログラマが真に欲しい型表現ではありません。これはc2atsがまだ開発途上であることにも原因がありますが、より大きな課題はC言語の関数定義がATS言語で使いたいレベルの不変条件を表明していないことに起因しています。このC言語における表明の不足については後の章で具体的に解説します。

現時点においてはc2atsの作るsatsファイルはRuby on Rails\cite{rails}のScaffoldのようなものだと考えることができます。c2atsで自動生成されたsatsファイルは手っ取り早くATSアプリケーションを作るための足場にすぎません。当該satsファイル内の関数シグニチャに問題があれば、手動で強化すべきです。当該satsファイルは、決っして製品コードにそのまま無変更で採用されるべきではありません。そのsatsファイルは多くの危険な関数シグニチャを含んでいるからです。しかしその危険性は元のC言語関数定義と同等のレベルです。

別の言い方をすると、元々危険であったC言語関数インターフェイスをc2atsによってATS言語に写像することで、ATSプログラマはその危険性をunsafe.satsなどの含む危険なキャストの使用という形で明確に知覚できるようになります。一旦知覚された危険性はその危険なコードを手動除去する過程で自然に安全になります。結果自動生成されたsatsファイルの安全性を段階的に高めることが可能になります。

\section{c2atsによる自動生成ルール}

前章ではc2atsの使い方について説明しました。この時c2atsがC言語ヘッダからどのようなsatsファイルを生成するのかを本章で説明します。また本論文では解説しませんが、構造体と構造体メンバーへのアクセサや関数ポインタもc2atsは自動変換します。

\subsection{プリミティブ型}

ATS言語のプリミティブ型はC言語の型と対応しています。表\ref{table:prim}にその対応を示します。

\begin{table}[htb]
  \caption{ATS言語とC言語のプリミティブ型}
  \label{table:prim}
  \centering
  \begin{tabular}{l|l}
    C言語の型名 & ATS言語の型名 \\ \hline
    bool & bool \\
    char & char \\
    signed char & schar \\
    unsigned char & uchar \\
    short & sint \\
    unsigned short & usint \\
    int & int \\
    unsigned int & uint \\
    long int & lint \\
    unsigned long int & ulint \\
    long long int & llint \\
    unsigned long int & ullint \\
    float & float \\
    double & double \\
    long double & ldouble \\
  \end{tabular}
\end{table}

\subsection{関数宣言}

以下のようなC言語の関数宣言があったとき、

\begin{lstlisting}
int function(int, char);
\end{lstlisting}

c2atsは以下のようなATSの関数宣言に変換します。

\begin{lstlisting}
fun fun_c2ats_function: (int, char) -> int = "mac#function"
\end{lstlisting}

関数名には \verb|fun_c2ats_| という前置詞が付けられます。\verb|=| の左辺においてはC言語からATS言語への単純な文法の変換です。\verb|"mac#function"| の部分には対応するC言語の関数名を指定します。この指定によって当該C言語関数をATS言語から呼び出し可能になります。

\subsection{ポインタ}

C言語のポインタをATS言語では \verb|ptr| 型として単に扱うこともできますが、この方法ではポインタをC言語における \verb|void *| のように扱うために、危険であると言えます。そこでc2atsは全てのポインタに対する駐観を自動生成します。

例えば、以下のようなC言語関数があるとき、

\begin{lstlisting}
int my_getopt (int, char **, char *);
\end{lstlisting}

c2atsは以下のようなATSの関数宣言に変換します。

\begin{lstlisting}
fun fun_c2ats_my_getopt: {l1,l1_1,l2:addr} (!ptr_v_2(char, l1, l1_1), !ptr_v_1(char, l2) | int, ptr l1, ptr l2) -> int = "mac#my_getopt"
\end{lstlisting}

この時 \verb|ptr_v_1|, \verb|ptr_v_2|, \verb|ptr_v_3| は以下のようにsatsファイルに出力されます。

\begin{lstlisting}
viewdef ptr_v_1 (a:t@ype, l:addr) = a @ l
dataview ptr_v_2 (a:t@ype+, l0: addr, l1: addr) =
  | ptr_v_2_cons(a, l0, l1) of (ptr l1 @ l0, ptr_v_1 (a, l1))
dataview ptr_v_3 (a:t@ype+, l0:addr, l1:addr, l2:addr) =
  | ptr_v_3_cons(a, l0, l1, l2) of (ptr l1 @ l0, ptr_v_2 (a, l1, l2))
\end{lstlisting}

ATS言語では帰納的な駐観を作ることも可能ですが、依存するアドレスの範囲を別々に指定したい場合を想定して型宣言の外に依存したアドレス全てを見せています。すなわちこの方式を使って、先の \verb|my_getopt| 関数の変換結果において、次のように1段目のポインタである \verb|l1| と \verb|l2| のみがNULLではなく、2段目のポインタである \verb|l1_1| はNULLであることを許容するような型シグニチャを書くことができます。

\begin{lstlisting}
fun fun_c2ats_my_getopt: {l1,l2:agz}{l1_1:addr} (!ptr_v_2(char, l1, l1_1), !ptr_v_1(char, l2) | int, ptr l1, ptr l2) -> int = "mac#my_getopt"
\end{lstlisting}

c2atsはこのようにポインタがNULLであることを許容されうるかどうかを推測しません。c2atsは全てのポインタにはNULLが許容されるにもかかわらず、駐観があるものと見なすため、当該関数は当該ポインタを(NULLであるかもしれないにもかかわらず)デリファレンスできると想定していることになります。これはC言語と同等に危険です。

本来、C言語関数の実装者は引数の入出力や引数と返り値のポインタの関連などについて意図を持って設計したはずですが、その意図をc2atsがC言語ヘッダから読み取ることは困難です。そこで現在のc2atsでは出力されたsatsファイルを利用してATSプログラミムを書く際に、より強い型を手動で割り当てることが奨励されます。

さらに、引数としての駐観はその依存するアドレスを全称量化で導入し、さらに関数が返っても消費しません。また返り値としての駐観はその依存するアドレスを存在量化で導入します。これは \verb|FCLOSE(3)| のように、実際には駐観を消費するであろう関数シグニチャでも同様です。

これもまた本来はC言語設計者はポインタの生存区間を意図して設計したはずですが、その意図をc2atsがC言語ヘッダから読み取ることは困難です。現在のc2atsでは出力されたsatsファイルに手動で強い型を割り当てることが奨励されます。

\section{現実的なアプリケーション: 自動生成された危険な関数の使用}

より現実的なアプリケーション例として「自分自身のソースコードを標準出力に印字するアプリケーション」を考えます。やはり以下のようなexample.hファイルがあるとします。

\lstinputlisting{example/fileread/example.h}

このとき、example.satsファイルを自動生成すると、その中には以下の関数がインポートされています。

\begin{lstlisting}
$ c2ats gen example.h > example.sats
$ vi example.sats
--snip--
abst@ype struct_c2ats__IO_FILE // FIXME! Forward declaration.
typedef type_c2ats_FILE = struct_c2ats__IO_FILE
fun fun_c2ats_fclose: {l1:addr} (!ptr_v_1(type_c2ats_FILE, l1) | ptr l1) -> int = "mac#fclose"
fun fun_c2ats_fopen: {l1,l2:addr} (!ptr_v_1(char, l1), !ptr_v_1(char, l2) | ptr l1, ptr l2) -> [l3:addr] (ptr_v_1(type_c2ats_FILE, l3) | ptr l3) = "mac#fopen"
fun fun_c2ats_fread: {l1:addr} (!ptr_v_1(type_c2ats_FILE, l1) | ptr, type_c2ats_size_t, type_c2ats_size_t, ptr l1) -> type_c2ats_size_t = "mac#fread"
--snip--
\end{lstlisting}

上記の3つの関数 \verb|fun_c2ats_fopen|, \verb|fun_c2ats_fread|, \verb|fun_c2ats_fclose| を使うことで、このアプリケーションを以下のように構築することができます。

\lstinputlisting{example/fileread/main.dats}

上記のmain.datsファイルは自動生成したexample.satsファイルと共にコンパイルできますが、以下の点で危険なコードです。

\begin{itemize}
\item 危険性1: 危険なAPIの入ったunsafe.satsをインポートしている
\item 危険性2: 任意の駐観を消費できる \verb|__consume_view| という証明関数を定義して使っている
\item 危険性3: 何の証明もない単なるポインタから任意の駐観を取り出せる \verb|ptr_vtake| を使っている
\item 危険性4: \verb|fun_c2ats_fread| 関数が駐観も長さ情報も持たない生のポインタ \verb|buf_ptr| を取っている
\item 危険性5: 任意の型を任意の型にキャストできる \verb|cast| という関数を使っている
\item 危険性6: \verb|my_fread| 関数の返り値は静的な変数 \verb|m| に依存しているがその値の範囲は \verb|m <= n| であるべき
\end{itemize}

次の章では上記の危険性を取り除くことで、段階的に安全なATSコードが手に入る様子を観察します。

\section{現実的なアプリケーション: 段階的な線形型の導入}

前章でのmain.datsとexample.satsを少しずつ修正して危険なコードを除去します。

\subsection{fun\_c2ats\_fopenがstring型を取るように}

危険性3は \verb|fun_c2ats_fopen| 関数が \verb|char| ポインタを引数に取るために当該ポインタのための駐観を作る必要性から生じたものです。そこで、以下のように関数シグニチャを変更します。

\begin{lstlisting}
$ vi example.sats
--snip--
fun fun_c2ats_fopen: (string, string) -> [l3:addr] (ptr_v_1(type_c2ats_FILE, l3) | ptr l3) = "mac#fopen"
--snip--
\end{lstlisting}

これで \verb|fun_c2ats_fopen| 関数は引数を \verb|string| 型で取るようになりました。結果main.datsを下記のように書き換えて、\verb|ptr_vtake| の使用を除去することができます。

\begin{lstlisting}
$ vi main.dats
--snip--
fun my_fopen (file: string, mode: string):
    [l:agz] (type_c2ats_FILE@l | ptr(l)) = ret where {
  val (pffp | fp) = fun_c2ats_fopen(file, mode)
  val () = assertloc(fp > 0)
  val ret = (pffp | fp)
}
--snip--
\end{lstlisting}

\subsection{fun\_c2ats\_fcloseで線形型を消費}

危険性2は \verb|fun_c2ats_fclose| 関数が返った後でもファイルポインタの駐観 \verb|pffp| が消費されないために発生していました。C言語の関数定義からは直接解釈することはできませんが、\verb|fclose| の定義では一度クローズしたファイルポインタは使用不能になるはずです。そのため \verb|fun_c2ats_fclose| は当該の駐観を消費すべきです。そこで関数シグニチャを以下のように修正します。

\begin{lstlisting}
$ vi example.sats
--snip--
fun fun_c2ats_fclose: {l1:agz} (ptr_v_1(type_c2ats_FILE, l1) | ptr l1) -> int = "mac#fclose"
--snip--
\end{lstlisting}

また同時に上記修正では、\verb|fclose| するファイルポインタは非NULLであることが望ましいので、当該ファイルポインタが依存している静的なアドレスを非NULLである \verb|agz| に設定しています。

すると、以下のように \verb|__consume_view| の使用が不要になり、\verb|main0| 関数から直接 \verb|fun_c2ats_fclose| 関数を呼び出せるようになります。

\begin{lstlisting}
$ vi main.dats
--snip--
implement main0 () = {
  val (pffp | fp) = my_fopen("main.dats", "r")
  val () = readshow(pffp | fp)
  val r = fun_c2ats_fclose(pffp | fp)
}
--snip--
\end{lstlisting}

\subsection{fun\_c2ats\_freadがstrnptr型を取るように}

危険性4を修正するために \verb|buf_ptr| の元になった、\verb|string_tabulate| 関数で確保した、長さ情報を静的に持つ \verb|strnptr| 型の値を直接 \verb|fun_c2ats_fread| 関数に渡せるように、関数シグニチャを修正します。

\begin{lstlisting}
$ vi example.sats
--snip--
fun fun_c2ats_fread: {l1:agz}{m:nat} (!ptr_v_1(type_c2ats_FILE, l1) | !strnptr(m)>>strnptr(o), type_c2ats_size_t, type_c2ats_size_t, ptr l1) -> #[o:nat | o <= m] size_t(o) = "mac#fread"
--snip--
\end{lstlisting}

上記の修正では \verb|fun_c2ats_fread| 関数の第1実引数に \verb|strnptr(m)| 型を渡し、この関数が返る時にはその型が \verb|strnptr(o)| であることを表明しています。ただし、このとき \verb|o| は \verb|o <= m| にならなければなりません。またこの関数の返り値も \verb|o| に依存しています。つまり \verb|fread| した後のバッファの長さはその返り値と等しいことが期待されています。

また同時に上記修正では、\verb|fread| するファイルポインタは非NULLであることが望ましいので、当該ファイルポインタが依存している静的なアドレスを非NULLである \verb|agz| に設定しています。

すると以下のように \verb|my_fread| 関数を修正して、\verb|fun_c2ats_fread| 関数に直接 \verb|strnptr| 型を渡せるようになります。

\begin{lstlisting}
$ vi main.dats
--snip--
fun my_fread {l:agz}{n:nat}
    (pffp: !type_c2ats_FILE@l | fp: ptr(l), len: size_t(n)):
    [m:int] (size_t(m), strnptr(m)) = ret where {
  implement{} string_tabulate$fopr(s) = '_'
  val buf_strnptr = string_tabulate(len)
  val buf_ptr = strnptr2ptr(buf_strnptr)
  val _ = $STRING.memset_unsafe(buf_ptr, 0, len)

  val r = fun_c2ats_fread(pffp | buf_strnptr, 1UL, $UN.cast2ulint(len), fp)
  val ret = (r, buf_strnptr)
}
--snip--
\end{lstlisting}

このとき、返り値と \verb|buf_strnptr| が依存する静的な長さと返り値 \verb|r| が依存する静的な長さが一致するので、\verb|cast| による危険なキャストも不要になり、危険性5も解消することができました。

\subsection{fun\_c2ats\_freadでsize\_t型を使う}

危険性6を解消するために、以下のように \verb|fun_c2ats_fread| 関数の引数を \verb|size_t| 型にして、さらにその値の範囲を明示します。

\begin{lstlisting}
$ vi example.sats
--snip--
fun fun_c2ats_fread: {l1:agz}{n,m:nat} (!ptr_v_1(type_c2ats_FILE, l1) | !strnptr(n*m)>>strnptr(o), size_t(n), size_t(m), ptr l1) -> #[o:nat | o <= n*m] size_t(o) = "mac#fread"
--snip--
\end{lstlisting}

静的な変数 \verb|n| と \verb|m| を全称量化で導入し、その値は0以上です。\verb|fun_c2ats_fread| 関数の第2実引数と第3実引数はそれぞれ \verb|n| と \verb|m| に依存し、さらに第1実引数である \verb|strnptr| 型の文字列は当該関数の呼び出し前は \verb|n*m| の長さです。本関数が呼び出された後では、\verb|strnptr| 型の文字列の長さと \verb|size_t| 型の返り値の値は \verb|o| で、その範囲は \verb|p <= n*m| です。

すると以下のように \verb|my_fread| 関数を修正して、当該関数の返り値である \verb|size_t| と \verb|strnptr| 型の文字列に \verb|m <= n| という制約をつけれるようになります。

\begin{lstlisting}
$ vi main.dats
fun my_fread {l:agz}{n:nat}
    (pffp: !type_c2ats_FILE@l | fp: ptr(l), len: size_t(n)):
    [m:nat | m <= n] (size_t(m), strnptr(m)) = ret where {
  implement{} string_tabulate$fopr(s) = '_'
  val buf_strnptr = string_tabulate(len)
  val buf_ptr = strnptr2ptr(buf_strnptr)
  val _ = $STRING.memset_unsafe(buf_ptr, 0, len)

  val r = fun_c2ats_fread(pffp | buf_strnptr, i2sz(1), len, fp)
  val ret = (r, buf_strnptr)
}
\end{lstlisting}

さらにもはやunsafe.satsのインポートも不要になり、危険性1も解消することができました。

\section{現実的なアプリケーション: 安全になった関数シグニチャ}

前章による段階的なコード修正によって、以下のようなアプリケーションが構築できました。

\lstinputlisting{example/welltyped_fileread/main.dats}

また、上記のアプリケーションは以下のsatsファイル中の関数シグニチャを使います。

\begin{lstlisting}
$ vi example_welltyped.sats
--snip--
abst@ype struct_c2ats__IO_FILE // FIXME! Forward declaration.
typedef type_c2ats_FILE = struct_c2ats__IO_FILE
fun fun_c2ats_fclose: {l1:agz} (ptr_v_1(type_c2ats_FILE, l1) | ptr l1) -> int = "mac#fclose"
fun fun_c2ats_fopen: (string, string) -> [l3:addr] (ptr_v_1(type_c2ats_FILE, l3) | ptr l3) = "mac#fopen"
fun fun_c2ats_fread: {l1:agz}{n,m:nat} (!ptr_v_1(type_c2ats_FILE, l1) | !strnptr(n*m)>>strnptr(o), size_t(n), size_t(m), ptr l1) -> #[o:nat | o <= n*m] size_t(o) = "mac#fread"
--snip--
\end{lstlisting}

このコードからは先の危険性1-5の全てを排除されています。

\section{制限と今後}

c2atsはまだ開発途上のために以下いくつか制限があります。

\begin{enumerate}
\item 単一のsatsファイルしか出力できません。大きなプログラムを扱う場合にはモジュール毎にsatsファイルを分割してインクルードしたい要求があります。
\item C言語の前方宣言をATS言語に上手く写像できません。C言語では中身の定義のない構造体を宣言した後、後続でその構造体へのポインタを使用し、さらにその後で実際の当該構造体の中身を定義することが可能でした。ところがATS言語ではこのような前方宣言を行なうことができません。現状は前方宣言に対応するATSコードとして同名の抽象データ型宣言を挿入することでコンパイル可能にしています。
\item C言語の関数宣言ではなく関数本体をATS言語に翻訳できません。
\item ATS言語で共用体を構造体と同様に扱うのは明らかに危険です。代数データ型を使うべきです。
\item constなどの特殊な修飾子やビットフィールドなどにはATS言語に等価な表現がありません。
\end{enumerate}

これらの制約の内、1,2,3については以下のように今後のc2atsの開発で解消できると考えます。

\begin{enumerate}
\item ATS言語の宣言がどのC言語ヘッダで宣言されていたか調べることで、C言語ヘッダと同じ構造のsatsファイル群を出力する機能を作成中です。
\item 前方宣言をできうるかぎりATS言語で宣言できる順序に整列します。整列できなかった前方宣言は本質的に循環しているため、手動で翻訳する必要があります。
\item gotoのないC言語コードは原理的にはATS言語に翻訳可能です。しかしgotoを含むC言語コードは例外のないATS言語コードに翻訳するにはなんらかのモデルが必要です。つまりgotoの用法をいくつかのモデル(大域脱出、リトライ、など)に分類した上で対応するATS言語のイディオムに変換することが可能かもしれません。
\end{enumerate}

残る制限については上記が解消した後、ATSコンパイラ原作者と協議の上対応策を決定する予定です。

\section{関連研究}

c2atsはC言語から高級言語を作成する唯一のプロジェクトではありません。

c2hs\cite{c2hs}はC言語のヘッダファイルとchsファイルという注釈入りのHaskellコードからHaskellのFFI定義を自動生成します。c2atsと異なり、chsファイルで注釈された対象のC言語コードに対してのみFFIを生成するために効率的であると言えます。大きなC言語コードの一部をATSコード化したい場合にはc2hsのような「興味のある対象だけを切り取って変換」する機能が必要でしょう。

corrode\cite{corrode}はC言語のヘッダファイルやソースファイルを入力としてRust言語のソースコードを出力します。このツールはC言語関数本体もRust言語に変換するため、c2atsはこれを将来の機能拡張の手本とすることができます。一方、Rust言語にはATS言語がそなえる依存型を持たないため、Rust言語に変換したコードの正確さを手動で強化しにくいでしょう。

\section{結論}

比較的単純な変換ルールを決めることで、C言語ヘッダ中の宣言をATS言語の宣言(satsファイル)に自動的翻訳することが可能であることを示しました。自動変換されたsatsファイルを使って型キャストを用いた危険なATS言語アプリケーションを作成できることを示しました。そのsatsファイルと危険なアプリケーションに段階的に線形型を導入することで、より安全な関数シグニチャとアプリケーションが手に入ることを示しました。最後に本ツールの現状での制限と開発計画を展望しました。

\section*{謝辞}
language-cという素晴しいライブラリを紹介してくれた村主崇行氏と、C言語の型表現をいかにしてATS言語の型表現に解釈しなおすか根気強いサポートをしてくれたHongwei Xiに感謝します。

% BibTeX %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\bibliographystyle{unsrt}
\bibliography{../bibtex/reference,../bibtex/jreference}

\end{document}
